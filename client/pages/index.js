import Head from "next/head";
import Image from "next/image";
import styles from "../styles/Home.module.css";
import { useState, useEffect, useMemo } from "react";
import {
  useSignMessage,
  useSignTypedData,
  useAccount,
  useContractRead,
  useNetwork,
} from "wagmi";
import { switchNetwork, fetchSigner } from "@wagmi/core";
import axios from "axios";
import "@rainbow-me/rainbowkit/styles.css";

import { verifyMessage } from "ethers/lib/utils";

import { getDefaultWallets, RainbowKitProvider } from "@rainbow-me/rainbowkit";
import { ConnectButton } from "@rainbow-me/rainbowkit";

const { ethers } = require("ethers");

const alchemyApiKey = process.env.NEXT_PUBLIC_ALCHEMY_ID;
const spenderAddress = "0x9023A64037D3f5DF231ad6e2780DbF0F74AbDA77";
const contractAddress = "0x61d5eE64b2308beE9ae5aE578B99e078ADc400e8";
// オペレーション簡略化のためdeadlineを固定 (2030/1/1 0:0:0)
const deadline = 1893423600;

const abi = require("./abi.json");
const chainId = 5;
const autotaskWebhookURL =
  "https://api.defender.openzeppelin.com/autotasks/14efb818-b399-4169-86f6-4225c5fa4472/runs/webhook/fd12b112-7a04-4a77-abcd-216169660a57/QVxddXQWs4bk39cXgzHW3V";

export default function Home() {
  const { signTypedDataAsync } = useSignTypedData();
  const { address, isConnected } = useAccount();
  const { chain } = useNetwork();
  const [isDefinitelyConnected, setIsDefinitelyConnected] = useState(false);
  const [signature, setSignature] = useState();
  const [ownTokenIds, setOwnTokenIds] = useState([]);
  const [tokenId, setTokenId] = useState(0);
  const [isSucceeded, setISucceeded] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");
  const [processing, setProcessing] = useState(false);
  const [txHash, setTxHash] = useState();

  const message = "Sign Message";

  useEffect(() => {
    if (isConnected) {
      setIsDefinitelyConnected(true);
      getOwnTokens();
    } else {
      setIsDefinitelyConnected(false);
    }
  }, [address]);

  const getOwnTokens = async () => {
    const apiUrl =
      "https://eth-goerli.g.alchemy.com/nft/v2/" +
      alchemyApiKey +
      "/getNFTs?owner=" +
      address +
      "&contractAddresses[]=" +
      contractAddress +
      "&withMetadata=false";
    const res = await axios.get(apiUrl);
    console.log(apiUrl);
    console.log(res);

    const tokenIdList = res.data.ownedNfts.map((nft) => Number(nft.id.tokenId));

    setOwnTokenIds(tokenIdList);
    setTokenId(tokenIdList[0]);
  };

  const sign = async () => {
    setProcessing(true);
    try {
      if (chain.id != chainId) {
        await switchNetwork({
          chainId: chainId,
        });
      }
    } catch (e) {
      setProcessing(false);
    }

    const contract = new ethers.Contract(
      contractAddress,
      abi,
      await fetchSigner()
    );

    const nonce = await contract.nonces(tokenId);

    const typedData = {
      types: {
        Permit: [
          { name: "spender", type: "address" },
          { name: "tokenId", type: "uint256" },
          { name: "nonce", type: "uint256" },
          { name: "deadline", type: "uint256" },
        ],
      },
      primaryType: "Permit",
      domain: {
        name: await contract.name(),
        version: "1",
        chainId: chainId,
        verifyingContract: contract.address,
      },
      message: {
        spender: spenderAddress,
        tokenId,
        nonce,
        deadline,
      },
    };
    console.log(typedData.message);
    // sign Permit
    try {
      const signature = await signTypedDataAsync({
        domain: typedData.domain,
        types: { Permit: typedData.types.Permit },
        value: typedData.message,
      });
      setSignature(signature);
    } finally {
      setProcessing(false);
    }
  };
  const transfer = async () => {
    setProcessing(true);
    setErrorMessage("");
    setISucceeded(false);

    const reqData = {
      from: address,
      to: spenderAddress,
      tokenId: tokenId,
      deadline,
      _data: "0x00",
      signature: signature,
    };
    const res = await axios.post(autotaskWebhookURL, JSON.stringify(reqData));
    console.log(res);
    console.log(res.data);
    if (res.data.status == "error") {
      setErrorMessage(res.data.message);
    } else {
      setISucceeded(true);
    }
    setProcessing(false);
  };
  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        <h1 className={styles.title}>Transfer With Permit Test!</h1>
        <p />

        <h2>1.Connect</h2>
        <ConnectButton
          accountStatus={{
            smallScreen: "avatar",
            largeScreen: "full",
          }}
          showBalance={false}
          chainStatus="none"
        />
        <div>
          {/* <div>{address}</div> */}
          {isDefinitelyConnected && ownTokenIds.length > 0 && (
            <center>
              <h2>2.Select</h2>
              <p>Select Your Own Token Ids</p>
              <select value={tokenId} onChange={(e) => setTokenId(e.value)}>
                {ownTokenIds.map((id) => (
                  <option key={id} value={id}>
                    {id}
                  </option>
                ))}
              </select>
              <p />
            </center>
          )}

          {isDefinitelyConnected && ownTokenIds.length == 0 && (
            <center>
              <h2>Please Get Test Token</h2>
              <a
                href="https://goerli.etherscan.io/address/0x61d5ee64b2308bee9ae5ae578b99e078adc400e8#writeProxyContract"
                target={"_blank"}
              >
                Mint on Etherscan (Click Here and Execute &quot;mint&quot;)
              </a>
            </center>
          )}
        </div>
        <div>
          {/* <div>{address}</div> */}
          {isDefinitelyConnected && tokenId > 0 && (
            <center>
              <h2>3.sign</h2>
              <button onClick={sign}>Sign</button>
              <p />
              <div>{signature}</div>
            </center>
          )}
        </div>
        <div>
          {/* <div>{address}</div> */}
          {signature && (
            <center>
              <h2>4.TransferWithPermit</h2>
              <button disabled={processing} onClick={transfer}>
                Transfer
              </button>
              <p />
              {errorMessage && <div>{errorMessage}</div>}
              {isSucceeded && (
                <a
                  href="https://goerli.etherscan.io/address/0x61d5ee64b2308bee9ae5ae578b99e078adc400e8"
                  target={"_blank"}
                >
                  Check Etherscan
                </a>
              )}
            </center>
          )}
        </div>
      </main>
    </div>
  );
}
